#include "stdio.h"
int sum;
/*
03.    一个操作数序列，从1，2，一直到n，栈A的深度大于n。现在可以进行两种操作：
04.    1.将一个数，从操作数序列的头端移动到栈的头端（对应数据结构栈的push操作）
05.    2.将一个数，从栈的头端移动到输出序列的尾端（对应数据结构的pop操作）
06.    现在对于任意一个N，输入端的数据一定是1，2，3...N，求出可能出现的输出端数据序列的种数。
07.    解题思路：
08.    就是利用递归回溯，每一个元素只可能进栈出栈一次，所以当所有元素都进过栈后统计所有情况的次数
09.*/

/*
12.    递归模拟入栈出栈的过程，因为问题是求解出栈的序列可能情况种类。
13.    因此在进行递归操作时要：先出栈，再入栈
14.*/

void dfs(int top,int head,int n)//top 为栈顶位置，head为操作数序列(队列)，经过一系列操作后队首位置
{
    if(head==n+1)//所有元素都已经进栈操作过一次，该次入栈(出栈)操作结束
    {
        sum++;
        return;
    }
    if(top>0)//栈顶指针
    {
        dfs(top-1,head,n); /*未出过栈 ，则出栈*/
    }
    if(head<n+1)
    {
        dfs(top+1,head+1,n); /*未入过栈，则入栈*/
    }
}

int main()//注意使用递归的方法去模拟出栈，入栈的操作，当数据稍大的时候，将会出现超时，或爆栈
{
    int n;
    scanf("%d",&n);
    sum=0;
    dfs(0,1,n);//开始时，栈为空，且操作数队列队首head指向序列第一个元素的位置
    printf("%d\n",sum);
    return 0;
}

//还有利用卡特兰数进行统计的算法，google可以找出很多参考资料